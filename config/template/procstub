#!/bin/sh

function fail() {
	echo $1
	exit
}

function register_node() {
	process=$1
	curl -s "${HYDRA_BOOT}/api/register_node?cluster=${CLUSTERID}&key=${process}&hostname=${HOSTNAME}"
}

function wait_nodes() {
	process=$1
	curl -s "${HYDRA_BOOT}/api/wait_nodes?cluster=${CLUSTERID}&key=${process}"
}

function wait_zookeeper() {
	zknodes=$(wait_nodes zookeeper)
cat > ${HYDRA_IMAGE}/etc/zookeeper.properties << EOF
# zknodes=${zknodes}
dataDir=./etc/zookeeper
clientPort=2181
maxClientCnxns=1000000
EOF
}

# setup environment
export RUNBIN="${HYDRA_IMAGE}/bin"
export PIDDIR="${HYDRA_IMAGE}/etc/pid"
export HYDRA_JAR="${HYDRA_IMAGE}/lib/hydra.jar"
export HYDRA_HOST="${HYDRA_HOST:-$(hostname)}"
export PATH="${PATH}:${RUNBIN}"

[ ! -d ${HYDRA_IMAGE} ] && fail "missing 'run' directory. aborting."
[ ! -f ${HYDRA_JAR} ] && fail "missing hydra exec jar @ ${HYDRA_JAR}"

export QUERY_OPT="-Ddebug.MeshQuerySource=2 -Dmesh.local.handlers=com.addthis.hydra.data.query.source.MeshQuerySource -Dmqmaster.mesh.peers=localhost -Dmeshy.senders=1 -Dmeshy.stream.prefetch=true -Dmqmaster.mesh.peer.port=5101 -Dmesh.query.root=minion -Dquery.tmpdir=log/query/tmp"
export QMASTER_OPT="${QUERY_OPT} -Xmx512M -Xms512M -Deps.mem.debug=10000 -Dbatch.job.log4j=1 -Dcs.je.cacheShared=1 -Dcs.je.deferredWrite=1 -Dhydra.query.debug=1 -Dcom.yammer.metrics.GcMonitor.enable=false -Ddebug.level.SourceTracker=1 -Ddebug.level.QueryCache=2 -Ddebug.level.MeshQueryMaster=2 -Dquery.cache.enable=false -DQueryCache.CACHE_DIR=log/query/cache -Dmqmaster.enableZooKeeper=true"
export QWORKER_OPT="${QUERY_OPT} -Xmx256M -Xms256M"
export MINION_OPT="-Xmx128M -Xms128M -Dminion.mem=512 -Dminion.localhost=${HYDRA_HOST} -Dminion.group=local -Dminion.web.port=7070 -Dspawn.localhost=localhost -Dhttp.post.max=327680 -Dminion.sparse.updates=1 -Dreplicate.cmd.delay.seconds=1 -Dbackup.cmd.delay.seconds=0"
export SPAWN_OPT="-Xmx128M -Xms128M -Dspawn.localhost=localhost -Dspawn.queryhost=${HYDRA_HOST} -Dspawn.status.interval=6000 -Dspawn.chore.interval=3000 -Dhttp.post.max=327680 -Dspawn.polltime=10000 -Dspawnbalance.min.disk.percent.avail.replicas=0.01 -Dspawn.auth.ldap=false -Dmesh.port=5000 -Djob.store.remote=false"
export MESH_OPT="-Xmx128M -Xms128M -Dmeshy.autoMesh=false -Dmeshy.throttleLog=true -Dmeshy.buffers.enable=true -Dmeshy.stream.maxopen=10000 -Ddebug.level.StreamService=0 -Ddebug.level.ChannelState=0"
export COMMON_OPT="-Dzk.servers=localhost:2181 -Dganglia.enable=false -Djava.net.preferIPv4Stack=true"
export HYDRA_OPT="-Dbatch.brokerHost=localhost -Dbatch.brokerPort=5672 -Dhydra.tree.cache.maxSize=250 -Dhydra.tree.page.maxSize=50 -Deps.mem.debug=0"
export LOG4J_OPT="-Dlog4j.defaultInitOverride=true -Dlog4j.configuration=${HYDRA_IMAGE}/etc/log4j.conf"
export JAVA_CMD="java -server ${JAVA_OPTS} ${COMMON_OPT} ${EXTOPT}"
export HYDRA_CMD="${JAVA_CMD} ${LOG4J_OPT} ${HYDRA_OPT}"
export HYDRA_EXE="-jar ${HYDRA_JAR}"

# pull in hydra properties if they exist
if [ -f ${HYDRA_IMAGE}/etc/hydra.properties ]; then
	CMD_ADD=$(grep = ${HYDRA_IMAGE}/etc/hydra.properties | while read one; do echo "-D${one}"; done)
	export JAVA_CMD="${JAVA_CMD} ${CMD_ADD}"
	export HYDRA_CMD="${HYDRA_CMD} ${CMD_ADD}"
fi

# flcow (copy-on-write) support for 64 bit linux & os x
case $(uname) in
	Linux)
		export LD_PRELOAD=${HYDRA_IMAGE}/lib/libflcow.so:${LD_PRELOAD}
		;;
	Darwin)
		export LD_PRELOAD=${HYDRA_IMAGE}/lib/libflcow.dylib:${LD_PRELOAD}
		;;
esac
export FLCOW_PATH="^${HYDRA_IMAGE}"
export FLCOW_EXCLUDE="\.((stats)|(pid)|(done)|(complete))$"

function testIsRunning() {
	PIDFILE=$1
	[ ! -f ${PIDFILE} ] && return 0
	PIDVAL=$(cat ${PIDFILE})
	if [ -d /proc ]; then
		[ -d /proc/${PIDVAL} ] && return 1
	else
		EXIST="$(ps ax | grep -v grep | grep ${PIDVAL})" 
		[ "${EXIST}" != "" ] && return 1
	fi
	return 0
}

function startProcess() {
	export PROCNAME=$1; shift
	cd ${HYDRA_IMAGE}
	PID="${PIDDIR}/pid.${PROCNAME}"
	LOG=log/${PROCNAME}.log
	testIsRunning ${PID}
	running=$?
	if [ ${running} -eq 0 ]; then
		echo "startProcess :: ${PROCNAME}"
		nohup $* > ${LOG} 2>&1 &
		echo "$!" > "${PID}"
		echo "started ${PROCNAME}"
	fi
}

function stopProcess() {
	echo "stopProcess :: $*"
	cd ${HYDRA_IMAGE}
	for process in $*; do
		if [ -f ${PIDDIR}/pid.${process} ]; then
			PID=$(cat ${PIDDIR}/pid.${process})
			tries=1
			if [ -d /proc ]; then
				# in linux, use /proc filesystem. yay
				while [ -d /proc/${PID} ]; do
					echo "stopping ${process} #${tries}"
					[ ${tries} -gt 5 ] && SIG="-9"
					kill ${SIG} ${PID} # 2>/dev/null
					[ ${tries} -gt 1 ] && sleep 1 || usleep 250000
					tries=$((tries+1))
				done
			else
				# everywhere else, use ps. booo
				SIG=""
				EXIST="$(ps ax | grep -v grep | grep ${PID})" 
				while [ "$(ps a | grep -v grep | grep ${PID})" != "" ]; do
					echo "stopping ${process} #${tries} @ ${PID}"
					[ ${tries} -gt 5 ] && SIG="-9"
					kill ${SIG} ${PID} 2>/dev/null || break
					[ ${tries} -gt 1 ] && sleep 1 || sleep 1
					tries=$((tries+1))
				done
			fi
			rm ${PIDDIR}/pid.${process}
		fi
	done
}

