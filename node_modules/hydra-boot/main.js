var uuid = require('node-uuid');
var level = require('levelup');
var http = require('http');
var path = require('path');
var swig = require('swig');
var url = require('url');
var fs = require('fs');
var server = null;
var db = null;

var swigLoader = {
    resolve : function(to, from) {
        console.log(['swig.resolve',to,from]);s
        return to;
    },
    load : function(ident, callback) {
        get(['template',ident], callback);
    }
};

var httpHandle = function(req, res) {
    console.log(['request',req.method, req.url]);
    if (!(req.method == 'GET' || req.method == 'POST')) {
        return httpFail(res);
    }
    var purl = url.parse(req.url, true);

    var func = complete[purl.pathname];
    if (func) return func(req, res, purl);

    for (var key in prefix) {
        if (purl.pathname.indexOf(key) == 0) {
            return prefix[key](req, res, purl);
        }
    }

    httpFail(res, "no valid target", 404);
};

var httpSendFile = function(res, filename) {
    try {
        var filePath = path.join(__dirname, ["image",filename].join('/'));
        var contentType = ctype[filename.substring(filename.lastIndexOf('.'))] || "text/binary";
        var contentLength = fs.fs.statSync(filePath);
        res.writeHead(200, {
            'Content-Type' : contentType,
            'Content-Length' : contentLength
        });
        fs.createReadStream(fileName).pipe(res);
    } catch (error) {
        httpFail(res, error, 500);
    }
};

var httpTemplate = function(res, templateName, values) {
    get(['template',templateName], function(err, data) {
        if (!err) {
            var render = swig.render(data, {locals:values});
            httpOK(res, render);
        } else {
            httpFail(res, err, 500);
        }
    });
};

var httpOK = function(res, msg) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end(typeof msg == 'string' ? msg : JSON.stringify(msg)+"\n");
};

var httpFail = function(res, msg, code) {
    res.writeHead(code | 404, {'Content-Type': 'text/plain'});
    res.end((typeof msg == "string" ? msg : "unsupported request "+msg) + "\n");
};

var key = function (arr) {
    return arr.join('-');
};

var get = function(arr, options, callback) {
    db.get(key(arr), options, callback);
};

var put = function(arr, val, options, callback) {
    db.put(key(arr), val, options, callback);
};

var getJS = function(arr, callback) {
    return get(arr, {valueEncoding:"json"}, callback)
};

var putJS = function(arr, val, callback) {
    db.put(arr, val, {valueEncoding:"json"}, callback);
};

var complete = {
    "/help" : function(req, res, url) {
        return httpOK(res, [
            "/api/list_clusters", "/api/create_cluster", "/api/get_cluster", "/api/delete_cluster", "/api/boot_node"
        ]);
    }
};

var prefix = {
    "/api/" : function(req, res, url) {
        var funcName = url.pathname.substring(5);
        var func = api[funcName];
        if (typeof func == 'undefined') {
            return httpFail(res, "invalid api endpoint '"+funcName+"'");
        }
        func(url.query, req.socket.remoteAddress, function(err, obj) {
            if (err) {
                httpFail(res, err);
            } else {
                httpOK(res, obj);
            }
        });
    },
    "/image/" : function(req, res, url) {
        return httpSendFile(res, url.pathname.substring(7));
    },
    "/render/" : function(req, res, url) {
        return httpTemplate(res, url.pathname.substring(8), url.query);
    }
};

var api = {
    db_load : function(query, remote, callback) {
        if (remote != "127.0.0.1") {
            return callback("not authorized");
        }
        exports.load();
        callback(null,{load:"success"});
    },

    db_dump : function(query, remote, callback) {
        if (remote != "127.0.0.1") {
            return callback("not authorized");
        }
        exports.dump();
        callback(null,{dump:"success"});
    },

    boot_node : function(query, remote, callback) {
        console.log(['boot node',query,remote]);
        /**
         * TODO
         * use cluster-hostname|hostip to find config record
         * otherwise use cluster id param and an identity array param
         * return templated boot script
         */
        if (query.cluster && query.process) {
            callback(null, 'boot using '+query.cluster+" & "+query.process);
        } else {
            getJS(['host',remote], function(err, val) {
                if (err) return callback(err);
                callback(null, val);
            });
        }
    },

    list_clusters : function(query, remote, callback) {
        var keys = [];
        var stream = db.createKeyStream({start:"cluster-"})
            .on('data', function(data) {
                if (!data.indexOf("cluster-") == 0) {
                    callback(null, keys);
                    stream.destroy();
                } else {
                    keys.push(data.substring(8));
                }
            })
            .on('end', function() {
                callback(null, keys);
            });
    },

    create_cluster : function(query, remote, callback) {
        var id = uuid.v1().replace(/-/g,'');
        var key = ['cluster',id];
        getJS(key, function(err, val) {
            if (err) {
                putJS(key, {template:query}, function(err) {
                    if (err) {
                        callback("db put fail");
                    } else {
                        callback(null, {cluster:id});
                    }
                });
            } else {
                callback("db key exists");
            }
        });
    },

    get_cluster : function(query, remote, callback) {
        var key = ['cluster',query.id];
        getJS(key, function(err, val) {
            if (err) {
                callback(err);
            } else {
                callback(null,val);
            }
        });
    },

    delete_cluster : function(query, remote, callback) {
        var keys = [];
        var start = key(['cluster',query.id]);
        var stream = db.createKeyStream({start:start})
            .on('data', function(data) {
                if (!data.indexOf(start) == 0) {
                    callback(null, keys);
                    stream.destroy();
                } else {
                    keys.push(data);
                    db.del(data);
                }
            })
            .on('end', function() {
                callback(null, keys);
            });
    }
};

var exports = {
    init : function(port) {
        if (server != null) {
            throw "server already initialized"
        }
        swig.setDefaults({ loader: swigLoader });
        server = http.createServer(function (req, res) {
            httpHandle(req, res);
        }).listen(port | 8008);
        db = level('cluster.db');
    },

    dump : function(dir) {
        var dir = dir || 'cluster.dump';
        try {
            fs.stat(dir, function(err, stats) {
                if (err) fs.mkdirSync(dir);
            });
        } catch (err) {
            console.log(err);
        }
        var close = !db;
        db = db || level('cluster.db');
        db.createReadStream()
            .on('data', function(data) {
                var key = data.key;
                var val = data.value;
                fs.writeFileSync([dir,key].join('/'), val);
            })
            .on('end', function() {
                if (close) db.close();
            });
    },

    load : function(dir) {
        var dir = dir || 'cluster.dump';
        var dirInfo = fs.statSync(dir);
        var close = !db;
        db = db || level('cluster.db');
        db.createWriteStream()
            .on('error', function(err) {
                throw err;
            })
            .on('end', function() {
                db.close();
            });
        var files = fs.readdirSync(dir);
        for (var i=0; i<files.length; i++) {
            var data = fs.readFileSync([dir,files[i]].join('/'));
            db.put(files[i], data);
        }
        if (close) db.close();
    }
};

module.exports = exports;
